(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{131:function(t,n,e){"use strict";e.r(n),e.d(n,"frontMatter",(function(){return i})),e.d(n,"metadata",(function(){return l})),e.d(n,"rightToc",(function(){return c})),e.d(n,"default",(function(){return u}));var a=e(2),o=e(6),r=(e(0),e(138)),i={id:"cpp",title:"C++"},l={id:"cpp",isDocsHomePage:!1,title:"C++",description:"cylon::CylonContext",source:"@site/docs/cpp.md",permalink:"/docs/cpp",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/cpp.md",sidebar:"someSidebar",previous:{title:"Architecture",permalink:"/docs/arch"},next:{title:"PyCylon",permalink:"/docs/python"}},c=[{value:"<code>cylon::CylonContext</code>",id:"cyloncyloncontext",children:[{value:"Initialization",id:"initialization",children:[]},{value:"Context methods",id:"context-methods",children:[]}]},{value:"<code>cylon::Table</code>",id:"cylontable",children:[{value:"Reading tables",id:"reading-tables",children:[]},{value:"Writing tables",id:"writing-tables",children:[]},{value:"<code>cylon::Table</code> Operations",id:"cylontable-operations",children:[]},{value:"<code>cylon::Table</code> Attributes",id:"cylontable-attributes",children:[]},{value:"C++ Examples",id:"c-examples",children:[]}]}],s={rightToc:c};function u(t){var n=t.components,e=Object(o.a)(t,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,e,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"cyloncyloncontext"},Object(r.b)("inlineCode",{parentName:"h2"},"cylon::CylonContext")),Object(r.b)("p",null,"The entry point to cylon operations"),Object(r.b)("h3",{id:"initialization"},"Initialization"),Object(r.b)("p",null,"Local initialization"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"  auto ctx = cylon::CylonContext::Init();\n")),Object(r.b)("p",null,"Distributed initialization"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"  auto mpi_config = new cylon::net::MPIConfig();\n  auto ctx = cylon::CylonContext::InitDistributed(mpi_config);\n")),Object(r.b)("h3",{id:"context-methods"},"Context methods"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),'  /**\n   * Completes and closes all operations under the context\n   */\n  void Finalize();\n\n  /**\n   * Adds a configuration\n   * @param <std::string> key\n   * @param <std::string> value\n   */\n  void AddConfig(const std::string &key, const std::string &value);\n\n  /**\n   * Returns a configuration\n   * @param <std::string> key\n   * @param <std::string> def Default value\n   * @return <std::string> configuration value\n   */\n  std::string GetConfig(const std::string &key, const std::string &def = "");\n\n  /**\n   * Returns the Communicator instance\n   * @return <cylon::net::Communicator>\n   */\n  net::Communicator *GetCommunicator() const;\n\n  /**\n   * Sets a Communicator\n   * @param <cylon::net::Communicator*> pointer to another communicator\n   */\n  void setCommunicator(net::Communicator *communicator1);\n\n  /**\n   * Sets if distributed\n   * @param <bool> distributed\n   */\n  void setDistributed(bool distributed);\n\n  /**\n   * Returns the local rank\n   * @return rank <int>\n   */\n  int GetRank();\n\n  /**\n   * Returns the world size\n   * @return world size <int>\n   */\n  int GetWorldSize();\n\n  /**\n   * Returns the neighbors in the world\n   * @param include_self\n   * @return a std::vector<int> of ranks\n   */\n  vector<int> GetNeighbours(bool include_self);\n\n  /**\n   * Returns memory pool\n   * @return <cylon::MemoryPool>\n   */\n  cylon::MemoryPool *GetMemoryPool();\n\n  /**\n   * Sets a memory pool\n   * @param <cylon::MemoryPool> mem_pool\n   */\n  void SetMemoryPool(cylon::MemoryPool *mem_pool);\n\n')),Object(r.b)("h2",{id:"cylontable"},Object(r.b)("inlineCode",{parentName:"h2"},"cylon::Table")),Object(r.b)("h3",{id:"reading-tables"},"Reading tables"),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"cylon::Table")," can be created from a csv file as follows. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),'std::shared_ptr<cylon::Table> table1;\nauto read_options = CSVReadOptions();\nauto status = Table::FromCSV(ctx, "/path/to/csv", table1, read_options))\n')),Object(r.b)("p",null,"Read a set of tables using threads, "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),'std::shared_ptr<cylon::Table> table1, table2;\nauto read_options = CSVReadOptions().UseThreads(true);\nauto status = Table::FromCSV(ctx, {"/path/to/csv1.csv", "/path/to/csv2.csv"}, {table1, table2}, read_options);\n')),Object(r.b)("p",null,"An ",Object(r.b)("inlineCode",{parentName:"p"},"arrow::Table")," can be imported as follows, "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"std::shared_ptr<cylon::Table> table1;\nstd::shared_ptr<arrow::Table> some_arrow_table = ...;\nauto status = Table::FromArrowTable(ctx, some_arrow_table, table1);\n")),Object(r.b)("h3",{id:"writing-tables"},"Writing tables"),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"cylon::Table")," can be written to a CSV file as follows, "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),'std::shared_ptr<cylon::Table> table1; \n...\nauto write_options = cylon::io::config::CSVWriteOptions();\nauto status = table1->WriteCSV("/path/to/csv", write_options);\n')),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"cylon::Table")," can be coverted into an ",Object(r.b)("inlineCode",{parentName:"p"},"arrow::Table")," by simply, "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),"std::shared_ptr<arrow::Table> some_arrow_table;\nstd::shared_ptr<cylon::Table> table1; \n...\nauto status = table1->ToArrowTable(some_arrow_table);\n")),Object(r.b)("h3",{id:"cylontable-operations"},Object(r.b)("inlineCode",{parentName:"h3"},"cylon::Table")," Operations"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"})," /**\n   * Do the join with the right table\n   * @param right the right table\n   * @param joinConfig the join configurations\n   * @param output the final table\n   * @return success\n   */\n  Status Join(const std::shared_ptr<Table> &right,\n              cylon::join::config::JoinConfig join_config,\n              std::shared_ptr<Table> *output);\n\n  /**\n   * Similar to local join, but performs the join in a distributed fashion\n   * @param right\n   * @param join_config\n   * @param output\n   * @return <cylon::Status>\n   */\n  Status DistributedJoin(const shared_ptr<Table> &right,\n                         cylon::join::config::JoinConfig join_config,\n                         std::shared_ptr<Table> *output);\n\n  /**\n   * Performs union with the passed table\n   * @param other right table\n   * @param output output table\n   * @return <cylon::Status>\n   */\n  Status Union(const std::shared_ptr<Table> &other, std::shared_ptr<Table> &output);\n\n  /**\n   * Similar to local union, but performs the union in a distributed fashion\n   * @param other\n   * @param output\n   * @return\n   */\n  Status DistributedUnion(const shared_ptr<Table> &other, shared_ptr<Table> &output);\n\n  /**\n   * Performs subtract/difference with the passed table\n   * @param right right table\n   * @param output output table\n   * @return <cylon::Status>\n   */\n  Status Subtract(const std::shared_ptr<Table> &right, std::shared_ptr<Table> &output);\n\n  /**\n   * Similar to local subtract/difference, but performs in a distributed fashion\n   * @param other\n   * @param output\n   * @return\n   */\n  Status DistributedSubtract(const shared_ptr<Table> &right, shared_ptr<Table> &output);\n\n  /**\n   * Performs intersection with the passed table\n   * @param other right table\n   * @param output output table\n   * @return <cylon::Status>\n   */\n  Status Intersect(const std::shared_ptr<Table> &other, std::shared_ptr<Table> &output);\n\n  /**\n   * Similar to local intersection, but performs in a distributed fashion\n   * @param other\n   * @param output\n   * @return\n   */\n  Status DistributedIntersect(const shared_ptr<Table> &other, shared_ptr<Table> &output);\n\n  /**\n   * Filters out rows based on the selector function\n   * @param selector lambda function returning a bool\n   * @param output\n   * @return\n   */\n  Status Select(const std::function<bool(cylon::Row)> &selector, std::shared_ptr<Table> &output);\n\n  /**\n   * Creates a simpler view of an existing table by dropping one or more columns\n   * @param project_columns\n   * @param output\n   * @return\n   */\n  Status Project(const std::vector<int64_t> &project_columns, std::shared_ptr<Table> &output);\n\n\n  /**\n   * Clears the table\n   */\n  void Clear();\n")),Object(r.b)("h3",{id:"cylontable-attributes"},Object(r.b)("inlineCode",{parentName:"h3"},"cylon::Table")," Attributes"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"})," /**\n   * Get the number of columns in the table\n   * @return numbre of columns\n   */\n  int32_t Columns();\n\n  /**\n   * Get the number of rows in this table\n   * @return number of rows in the table\n   */\n  int64_t Rows();\n\n  /**\n   * Print the complete table\n   */\n  void Print();\n\n  /**\n   * Print the table from row1 to row2 and col1 to col2\n   * @param row1 first row to start printing (including)\n   * @param row2 end row to stop printing (including)\n   * @param col1 first column to start printing (including)\n   * @param col2 end column to stop printing (including)\n   */\n  void Print(int row1, int row2, int col1, int col2);\n\n  /**\n   * Get the id associated with this table\n   * @return string id\n   */\n  std::string GetID() {\n    return this->id_;\n  }\n\n  /**\n   * Returns the cylon Context\n   * @return\n   */\n  cylon::CylonContext *GetContext();\n")),Object(r.b)("h3",{id:"c-examples"},"C++ Examples"),Object(r.b)("p",null,"Following is a simple C++ API example. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cpp"}),'#include <glog/logging.h>\n#include <net/mpi/mpi_communicator.hpp>\n#include <ctx/cylon_context.hpp>\n#include <table.hpp>\n\nint main(int argc, char *argv[]) {\n  if (argc < 3) {\n    LOG(ERROR) << "There should be two arguments with paths to csv files";\n    return 1;\n  }\n  std::shared_ptr<cylon::Table> first_table, second_table, joined;\n\n  auto mpi_config = new cylon::net::MPIConfig();\n  auto ctx = cylon::CylonContext::InitDistributed(mpi_config);\n\n  auto read_options = cylon::io::config::CSVReadOptions().UseThreads(false).BlockSize(1 << 30);\n  auto status = cylon::Table::FromCSV(ctx, argv[1], first_table, read_options);\n  if (!status.is_ok()) {\n    LOG(INFO) << "Table reading failed " << argv[1];\n    ctx->Finalize();\n    return 1;\n  }\n\n  status = cylon::Table::FromCSV(ctx, argv[2], second_table, read_options);\n  if (!status.is_ok()) {\n    LOG(INFO) << "Table reading failed " << argv[2];\n    ctx->Finalize();\n    return 1;\n  }\n  LOG(INFO) << "Read tables completed!";\n\n  status = first_table->DistributedJoin(second_table, cylon::join::config::JoinConfig::InnerJoin(0, 0), &joined);\n  if (!status.is_ok()) {\n    LOG(INFO) << "Table join failed ";\n    ctx->Finalize();\n    return 1;\n  }\n\n  LOG(INFO) << "First table had : " << first_table->Rows() << " and Second table had : "\n            << second_table->Rows() << ", Joined has : " << joined->Rows();\n  LOG(INFO) << "Join completed!";\n  \n  ctx->Finalize();\n  return 0;\n}\n')),Object(r.b)("p",null,"Further examples can be found in ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/cylondata/cylon/tree/master/cpp/src/examples"}),"Cylon examples in Github"),"."))}u.isMDXComponent=!0},138:function(t,n,e){"use strict";e.d(n,"a",(function(){return p})),e.d(n,"b",(function(){return m}));var a=e(0),o=e.n(a);function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function l(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?i(Object(e),!0).forEach((function(n){r(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function c(t,n){if(null==t)return{};var e,a,o=function(t,n){if(null==t)return{};var e,a,o={},r=Object.keys(t);for(a=0;a<r.length;a++)e=r[a],n.indexOf(e)>=0||(o[e]=t[e]);return o}(t,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)e=r[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(o[e]=t[e])}return o}var s=o.a.createContext({}),u=function(t){var n=o.a.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):l(l({},n),t)),e},p=function(t){var n=u(t.components);return o.a.createElement(s.Provider,{value:n},t.children)},b={inlineCode:"code",wrapper:function(t){var n=t.children;return o.a.createElement(o.a.Fragment,{},n)}},d=o.a.forwardRef((function(t,n){var e=t.components,a=t.mdxType,r=t.originalType,i=t.parentName,s=c(t,["components","mdxType","originalType","parentName"]),p=u(e),d=a,m=p["".concat(i,".").concat(d)]||p[d]||b[d]||r;return e?o.a.createElement(m,l(l({ref:n},s),{},{components:e})):o.a.createElement(m,l({ref:n},s))}));function m(t,n){var e=arguments,a=n&&n.mdxType;if("string"==typeof t||a){var r=e.length,i=new Array(r);i[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=t,l.mdxType="string"==typeof t?t:a,i[1]=l;for(var s=2;s<r;s++)i[s]=e[s];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,e)}d.displayName="MDXCreateElement"}}]);